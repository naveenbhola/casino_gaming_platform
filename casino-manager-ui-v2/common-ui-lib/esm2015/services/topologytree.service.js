import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
/**
 * if you need to provide it at global level do not specify the module here just write the 'root', this is restricted to module if you
 * want to use the service need to import TopologyTreeModule.
 */
export class TopologytreeService {
    constructor(_http) {
        this._http = _http;
    }
    getTopologyNodes(url) {
        return this._http.get(url);
    }
    getTopologyTypes(url) {
        return this._http.get(url);
    }
    getTopologyNodeByNodeId(url, params = null) {
        return this._http.get(url, { params });
    }
    getAccessOrVirtualGroupNodes(url, params = null) {
        return this._http.get(url, { params });
    }
    getTopologyNodeUnassigned(url) {
        return this._http.get(url);
    }
}
TopologytreeService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TopologytreeService_Factory() { return new TopologytreeService(i0.ɵɵinject(i1.HttpClient)); }, token: TopologytreeService, providedIn: "root" });
TopologytreeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TopologytreeService.ctorParameters = () => [
    { type: HttpClient }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9wb2xvZ3l0cmVlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9jb21tb24tdWktdjIvc3JjL2FwcC9zZXJ2aWNlcy90b3BvbG9neXRyZWUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBQyxVQUFVLEVBQTJCLE1BQU0sc0JBQXNCLENBQUM7OztBQTRDMUU7OztHQUdHO0FBSUgsTUFBTSxPQUFPLG1CQUFtQjtJQUM5QixZQUFvQixLQUFpQjtRQUFqQixVQUFLLEdBQUwsS0FBSyxDQUFZO0lBQUksQ0FBQztJQUV4QyxnQkFBZ0IsQ0FBQyxHQUFHO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFpQyxDQUFDO0lBQy9ELENBQUM7SUFDRCxnQkFBZ0IsQ0FBQyxHQUFHO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFpQyxDQUFDO0lBQy9ELENBQUM7SUFFRCx1QkFBdUIsQ0FBQyxHQUFHLEVBQUUsU0FBcUIsSUFBSTtRQUNsRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLE1BQU0sRUFBRSxDQUFpQyxDQUFDO0lBQzNFLENBQUM7SUFDRCw0QkFBNEIsQ0FBQyxHQUFHLEVBQUUsU0FBcUIsSUFBSTtRQUN2RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLE1BQU0sRUFBRSxDQUFvQyxDQUFDO0lBQzlFLENBQUM7SUFDRCx5QkFBeUIsQ0FBQyxHQUFHO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFpQyxDQUFDO0lBQy9ELENBQUM7Ozs7WUFyQkosVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFsRE8sVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SHR0cENsaWVudCwgSHR0cFBhcmFtcywgSHR0cFJlc3BvbnNlfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElUb3BvbG9neU5vZGVzIHtcbiAgICBtZXRhOiB7XG4gICAgICAgIGhyZWY6IHN0cmluZyxcbiAgICAgICAgbWVkaWFUeXBlOiBzdHJpbmdcbiAgICB9O1xuICAgIG5vZGVJZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzaG9ydE5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBudW1iZXI7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBkZWxldGVkOiBib29sZWFuO1xuICAgIHJldGlyZWQ6IGJvb2xlYW47XG4gICAgcGFyZW50Tm9kZUlkOiBudW1iZXI7XG4gICAgcGFyZW50Tm9kZUhyZWY6IHN0cmluZztcbiAgICBwYXRoOiBzdHJpbmc7XG4gICAgY2hpbGROb2Rlc0hyZWZzOiBBcnJheTxhbnk+O1xuICAgIGNyZWF0ZWREdG06IHN0cmluZztcbiAgICB1cGRhdGVkRHRtOiBzdHJpbmc7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgY2hpbGRyZW46IEFycmF5PGFueT47XG59XG5cblxuLyoqXG4gKiBBVkc6KEFjY2VzcyBvciBWaXJ0dWFsIEdyb3VwKSBub2RlcywgdGhpcyBpbnRlcmZhY2UgaGFzIGNvbW1vbiBwcm9wZXJ0aWVzIGZvciBhY2Nlc3MgYW5kIHZpcnR1YWwgZ3JvdXAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRvcG9sb2d5QVZHTm9kZXMge1xuICAgIGNyZWF0ZWREdG06IHN0cmluZztcbiAgICBncm91cE5hbWU6IHN0cmluZztcbiAgICBncm91cFR5cGU6IHN0cmluZztcbiAgICBtZXRhOiB7XG4gICAgICAgIGhyZWY6IHN0cmluZyxcbiAgICAgICAgbWVkaWFUeXBlOiBzdHJpbmdcbiAgICB9O1xuICAgIHRvcG9sb2d5R3JvdXBJZDogbnVtYmVyO1xuICAgIHRvcG9sb2d5SWQ6IG51bWJlcjtcbiAgICB0b3BvbG9neU5vZGVJZHM6IEFycmF5PGFueT47XG4gICAgdXBkYXRlZER0bTogc3RyaW5nO1xuICAgIHVzZXJJZDogbnVtYmVyO1xufVxuXG4vKipcbiAqIGlmIHlvdSBuZWVkIHRvIHByb3ZpZGUgaXQgYXQgZ2xvYmFsIGxldmVsIGRvIG5vdCBzcGVjaWZ5IHRoZSBtb2R1bGUgaGVyZSBqdXN0IHdyaXRlIHRoZSAncm9vdCcsIHRoaXMgaXMgcmVzdHJpY3RlZCB0byBtb2R1bGUgaWYgeW91XG4gKiB3YW50IHRvIHVzZSB0aGUgc2VydmljZSBuZWVkIHRvIGltcG9ydCBUb3BvbG9neVRyZWVNb2R1bGUuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFRvcG9sb2d5dHJlZVNlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9odHRwOiBIdHRwQ2xpZW50KSB7IH1cblxuICAgIGdldFRvcG9sb2d5Tm9kZXModXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9odHRwLmdldCh1cmwpIGFzIE9ic2VydmFibGU8SVRvcG9sb2d5Tm9kZXNbXT47XG4gICAgfVxuICAgIGdldFRvcG9sb2d5VHlwZXModXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9odHRwLmdldCh1cmwpIGFzIE9ic2VydmFibGU8SVRvcG9sb2d5Tm9kZXNbXT47XG4gICAgfVxuXG4gICAgZ2V0VG9wb2xvZ3lOb2RlQnlOb2RlSWQodXJsLCBwYXJhbXM6IEh0dHBQYXJhbXMgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9odHRwLmdldCh1cmwsIHsgcGFyYW1zIH0pIGFzIE9ic2VydmFibGU8SVRvcG9sb2d5Tm9kZXNbXT47XG4gICAgfVxuICAgIGdldEFjY2Vzc09yVmlydHVhbEdyb3VwTm9kZXModXJsLCBwYXJhbXM6IEh0dHBQYXJhbXMgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9odHRwLmdldCh1cmwsIHsgcGFyYW1zIH0pIGFzIE9ic2VydmFibGU8SVRvcG9sb2d5QVZHTm9kZXNbXT47XG4gICAgfVxuICAgIGdldFRvcG9sb2d5Tm9kZVVuYXNzaWduZWQodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9odHRwLmdldCh1cmwpIGFzIE9ic2VydmFibGU8SVRvcG9sb2d5Tm9kZXNbXT47XG4gICAgfVxufVxuIl19